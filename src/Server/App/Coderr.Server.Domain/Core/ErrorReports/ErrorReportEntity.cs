using System;
using System.Collections.Generic;
using System.Linq;
using System.Security.Claims;
using System.Text.RegularExpressions;

// ReSharper disable AutoPropertyCanBeMadeGetOnly.Local

namespace Coderr.Server.Domain.Core.ErrorReports
{
    /// <summary>
    ///     Represents the incoming error report, unmodified (to allow us to do further processing in the future)
    /// </summary>
    /// <remarks>
    ///     <para>
    ///         Important! The entity suffers from temporal coupling since we do not want to generate the hash code in the
    ///         receiving web API but in the core windows service. As such
    ///         the report can't be identified until the windows service has received it from the queue.
    ///     </para>
    /// </remarks>
    public class ErrorReportEntity
    {
        private const string RemoveLineNumbersRegEx = @"^(.*)(:[\w]+ [\d]+)";
        List<ErrorReportContextCollection> _collections = new List<ErrorReportContextCollection>();

        /// <summary>
        ///     Creates a new instance of <see cref="ErrorReportEntity" />.
        /// </summary>
        /// <param name="applicationId">Application that the report belongs to</param>
        /// <param name="clientReportId">error id generated by the client library</param>
        /// <param name="createdAtUtc">when the client library created the report</param>
        /// <param name="exception">exception</param>
        /// <param name="contexts">context collections</param>
        /// <exception cref="ArgumentNullException"></exception>
        /// <exception cref="ArgumentOutOfRangeException"></exception>
        public ErrorReportEntity(int applicationId, string clientReportId, DateTime createdAtUtc,
            ErrorReportException exception, IEnumerable<ErrorReportContextCollection> contexts)
        {
            if (clientReportId == null) throw new ArgumentNullException("clientReportId");
            if (exception == null) throw new ArgumentNullException("exception");
            if (contexts == null) throw new ArgumentNullException("contexts");
            if (applicationId <= 0) throw new ArgumentOutOfRangeException("applicationId");

            ClientReportId = clientReportId;
            ApplicationId = applicationId;
            CreatedAtUtc = createdAtUtc;
            Exception = exception;
            //GenerateHashCodeIdentifier();
            _collections.AddRange(contexts);
        }

        /// <summary>
        ///     Serialization constructor
        /// </summary>
        protected ErrorReportEntity()
        {
        }

        /// <summary>
        ///     PK of the application that this entity is reported for
        /// </summary>
        public int ApplicationId { get; set; }

        /// <summary>
        ///     Used to identify this incident when the hash code is the same as for other incidents.
        /// </summary>
        /// <summary>
        ///     Gets or sets id from the client library
        /// </summary>
        public string ClientReportId { get; private set; }

        /// <summary>
        ///     Context collection
        /// </summary>
        public IReadOnlyList<ErrorReportContextCollection> ContextCollections
        {
            get { return _collections; }
        }

        /// <summary>
        ///     When this entity was created (in the server)
        /// </summary>
        public DateTime CreatedAtUtc { get; private set; }

        /// <summary>
        ///     Thrown exception
        /// </summary>
        public ErrorReportException Exception { get; set; }

        /// <summary>
        ///     PK
        /// </summary>
        public int Id { get; private set; }

        /// <summary>
        ///     Gets incident that this report belongs to.
        /// </summary>
        public int IncidentId { get; set; }

        /// <summary>
        ///     Remote address from where the report was received.
        /// </summary>
        public string RemoteAddress { get; set; }


        /// <summary>
        ///     Hash code generated for the exception.
        /// </summary>
        /// <remarks>
        ///     Be aware that multiple different incidents (yes, <see cref="IncidentBeingAnalyzed" /> may have the same hash code).
        /// </remarks>
        public string ReportHashCode { get; private set; }

        /// <summary>
        ///     Denormalization to be able to generate lists quicker (this is really Exception.Message)
        /// </summary>
        public string Title { get; set; }


        /// <summary>
        ///     User/Site/application that the report is for.
        /// </summary>
        public ClaimsPrincipal User { get; set; }

        /// <summary>
        /// System environment ("Production", "Test" etc") that the error was reported in.
        /// </summary>
        public string EnvironmentName { get; set; }

        /// <summary>
        ///     Used when we get hash code collisions to identify the correct incident.
        /// </summary>
        public string GenerateHashCodeIdentifier()
        {
            var identifier = Exception.FullName + "\r\n";
            if (string.IsNullOrEmpty(Exception.StackTrace))
                return identifier;

            var trace = StripLineNumbers(Exception.StackTrace);
            var pos = trace.IndexOf("\r\n", StringComparison.Ordinal);
            if (pos != -1)
                identifier += trace.Substring(0, pos);

            return identifier;
        }

        public string GenerateHashCodeIdentifier2()
        {

            var hashSource = $"{Exception.FullName ?? Exception.Name}\r\n";
            var foundHashSource = false;

            // the client libraries can by themselves specify how we should identify
            // unique incidents. We then use that identifier in combination with the exception name.
            var collection = ContextCollections.FirstOrDefault(x => x.Name == "CoderrData");
            if (collection != null)
            {
                if (collection.Properties.TryGetValue("HashSource", out var reportHashSource))
                {
                    foundHashSource = true;
                    hashSource += reportHashSource;
                }
                else
                {
                    var trace = StripLineNumbers(Exception.StackTrace);
                    var pos = trace.IndexOf("\r\n", StringComparison.Ordinal);
                    if (pos != -1)
                        hashSource += trace.Substring(0, pos);
                }
            }
            if (!foundHashSource)
            {
                // This identifier is determined by the developer when  the error is generated.
                foreach (var contextCollection in ContextCollections)
                {
                    if (!contextCollection.Properties.TryGetValue("ErrorHashSource", out var ourHashSource))
                        continue;

                    hashSource = ourHashSource;
                    break;
                }
            }

            var hash = 23;
            foreach (var c in hashSource)
            {
                hash = hash * 31 + c;
            }
            return hash.ToString("X");
        }
        private static string StripLineNumbers(string stacktrace)
        {
            var re = new Regex(RemoveLineNumbersRegEx, RegexOptions.Multiline);
            return re.Replace(stacktrace, "$1", 1000);
        }

        /// <summary>
        ///     Temporal coupling, but the only way I could figure out.
        /// </summary>
        /// <param name="hashCode">hashcode used to see if this is an unique exception</param>
        /// <exception cref="ArgumentNullException">hashCode</exception>
        public void Init(string hashCode)
        {
            if (hashCode == null) throw new ArgumentNullException("hashCode");
            ReportHashCode = hashCode;
        }

        /// <summary>Returns a string that represents the current object.</summary>
        /// <returns>A string that represents the current object.</returns>
        /// <filterpriority>2</filterpriority>
        public override string ToString()
        {
            return Exception != null ? Exception.Message : "Exception was not included";
        }

        public void Add(ErrorReportContextCollection collection)
        {
            if (collection == null) throw new ArgumentNullException(nameof(collection));
            _collections.Add(collection);
        }
    }
}